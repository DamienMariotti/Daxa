#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 1, local_size_y = 512) in;

#include "fftutil.glsl"

layout(set = 0, binding = 3, rg16) uniform image2D images[];
layout(set = 0, binding = 1) uniform sampler2D sampledImages[];

layout(push_constant) uniform Push{
    uint inImageId;
    uint outImageId;
    uint width;
    uint height;
    // pass 0 is red channel, pass 1 is green, pass 2 blue
    uint pass;
    uint log2N;
} push;

shared uint packedValues[1024][2];

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y * 2);
    uint N = uint(1) << push.log2N;
    // threads skip every second pixel as we do the butterly battern
    uint n = coord.y;   

    vec3 inImageMask;
    switch (push.pass) {
    case 0: 
        inImageMask = vec3(1,0,0);
        break;
    case 1: 
        inImageMask = vec3(0,1,0);
        break;
    case 2: 
        inImageMask = vec3(0,0,1);
        break;
    default:
        break;
    }

    // each thread executes two paths, in the beginning we load two pixel values
    vec3 readInPixel = texelFetch(sampledImages[push.inImageId], coord, 0).rgb;
    readInPixel *= inImageMask;
    float channelValue = readInPixel.r + readInPixel.g + readInPixel.b;
    packedValues[n][0] = packHalf2x16(vec2(channelValue,0));
    readInPixel = texelFetch(sampledImages[push.inImageId], coord + ivec2(0,1), 0).rgb;
    readInPixel *= inImageMask;
    channelValue = readInPixel.r + readInPixel.g + readInPixel.b;
    packedValues[n+1][0] = packHalf2x16(vec2(channelValue,0));

    for (uint iter = 1; iter < push.log2N; iter++) {
        barrier();

    }

    // debug write real part
    imageStore(images[push.outImageId], coord, vec4(unpackHalf2x16(packedValues[n][0]).x, 0, 0, 0));
    imageStore(images[push.outImageId], coord + ivec2(0,1), vec4(unpackHalf2x16(packedValues[n + 1][0]).x, 0, 0, 0));
}