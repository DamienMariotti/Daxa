#version 450
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 1, rg16) uniform texture2D imageViews[];
layout(set = 0, binding = 3, rgba8) uniform writeonly image2D rgba8ImageView[];
layout(set = 0, binding = 0) uniform sampler2D samplers[];

#include "common.glsl"

layout(std140, push_constant) uniform Push{
    uint globalsId;
    uint inImgId;
    uint rOutImgId;
    uint gOutImgId;
    uint bOutImgId;
    uint inWidth;
    uint inHeight;
    uint outWidth;
    uint outHeight;
    float minBrightness;
    float padWidth;     // 0..1
    float padHeight;    // 0..1
} push;

void main() {
    ivec2 index = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    uint subWidth = push.outWidth - push.padWidth;
    uint subHeight = push.outHeight - push.padHeight;
    if (index.x < subWidth && index.y < subHeight) {
        vec2 coord = vec2(
            float(index.x) / float(subWidth),
            float(index.y) / float(subHeight)
        );
        vec3 fetch = texture(
            imageViews[push.inImgId],
            samplers[globals.generalSamplerId]
        ).rgb;

        if (fetch.r < push.minBrightness) {
            fetch.r = 0;
        }
        imgStore(rgba8ImageView[push.rOutImgId], index, fetch.r);
        if (fetch.g < push.minBrightness) {
            fetch.g = 0;
        }
        imgStore(ggba8ImageView[push.rOutImgId], index, fetch.g);
        if (fetch.b < push.minBrightness) {
            fetch.b = 0;
        }
        imgStore(rgba8ImageView[push.bOutImgId], index, fetch.b);
    }
}