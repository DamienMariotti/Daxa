#version 450
#extension GL_KHR_vulkan_glsl : enable

// clang-format off
const uint Air         = 0;
const uint Brick       = 1;
const uint Cactus      = 2;
const uint Cobblestone = 3;
const uint DiamondOre  = 4;
const uint Dirt        = 5;
const uint DriedShrub  = 6;
const uint Grass       = 7;
const uint Gravel      = 8;
const uint Leaves      = 9;
const uint Log         = 10;
const uint Planks      = 11;
const uint Rose        = 12;
const uint Sand        = 13;
const uint Sandstone   = 14;
const uint Stone       = 15;
const uint TallGrass   = 16;
const uint Water       = 17;

const uint Plains = 0;
const uint Forest = 1;
const uint Desert = 2;
const uint Beach = 3;
// clang-format on

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const uvec3 CHUNK_SIZE = uvec3(16);
const uint RENDER_DIST_XZ = 4;
const uvec3 CHUNK_MAX = uvec3(16, 6, 16);

struct ChunkgenBuffer {
    uint blocks[CHUNK_SIZE.x * CHUNK_SIZE.y * CHUNK_SIZE.z];
};

layout(set = 0, binding = 0) buffer chunk_buffer_0 {
    ChunkgenBuffer chunks_0[CHUNK_MAX.x * CHUNK_MAX.y * CHUNK_MAX.z];
};
layout(set = 0, binding = 1) buffer chunk_buffer_1 {
    ChunkgenBuffer chunks_1[CHUNK_MAX.x * CHUNK_MAX.y * CHUNK_MAX.z];
};

layout(push_constant) uniform Push {
    vec3 pos;
}
p;

int fastfloor(float fp) {
    int i = int(fp);
    return (fp < i) ? (i - 1) : (i);
}

const uint perm[256] = {
    // clang-format off
    151, 160, 137, 91,  90,  15,  131, 13,  201, 95,  96,  53,  194, 233, 7,   225,
    140, 36,  103, 30,  69,  142, 8,   99,  37,  240, 21,  10,  23,  190, 6,   148,
    247, 120, 234, 75,  0,   26,  197, 62,  94,  252, 219, 203, 117, 35,  11,  32,
    57,  177, 33,  88,  237, 149, 56,  87,  174, 20,  125, 136, 171, 168, 68,  175,
    74,  165, 71,  134, 139, 48,  27,  166, 77,  146, 158, 231, 83,  111, 229, 122,
    60,  211, 133, 230, 220, 105, 92,  41,  55,  46,  245, 40,  244, 102, 143, 54,
    65,  25,  63,  161, 1,   216, 80,  73,  209, 76,  132, 187, 208, 89,  18,  169,
    200, 196, 135, 130, 116, 188, 159, 86,  164, 100, 109, 198, 173, 186, 3,   64,
    52,  217, 226, 250, 124, 123, 5,   202, 38,  147, 118, 126, 255, 82,  85,  212,
    207, 206, 59,  227, 47,  16,  58,  17,  182, 189, 28,  42,  223, 183, 170, 213,
    119, 248, 152, 2,   44,  154, 163, 70,  221, 153, 101, 155, 167, 43,  172, 9,
    129, 22,  39,  253, 19,  98,  108, 110, 79,  113, 224, 232, 178, 185, 112, 104,
    218, 246, 97,  228, 251, 34,  242, 193, 238, 210, 144, 12,  191, 179, 162, 241,
    81,  51,  145, 235, 249, 14,  239, 107, 49,  192, 214, 31,  181, 199, 106, 157,
    184, 84,  204, 176, 115, 121, 50,  45,  127, 4,   150, 254, 138, 236, 205, 93,
    222, 114, 67,  29,  24,  72,  243, 141, 128, 195, 78,  66,  215, 61,  156, 180,
    // clang-format on
};

int hash(int i) { return int(perm[uint(i)]); }

float grad(int hash, float x) {
    const int h = hash & 0x0F;
    float grad = 1.0f + (h & 7);
    if ((h & 8) != 0)
        grad = -grad;
    return (grad * x);
}
float grad(int hash, float x, float y) {
    const int h = hash & 0x3F;
    const float u = h < 4 ? x : y;
    const float v = h < 4 ? y : x;
    return ((h & 1) == 1 ? -u : u) + ((h & 2) == 1 ? -2.0f * v : 2.0f * v);
}
float grad(int hash, float x, float y, float z) {
    int h = hash & 15;
    float u = h < 8 ? x : y;
    float v = h < 4 ? y : h == 12 || h == 14 ? x
                                             : z;
    return ((h & 1) == 1 ? -u : u) + ((h & 2) == 1 ? -v : v);
}
float noise(float x) {
    float n0, n1;

    int i0 = fastfloor(x);
    int i1 = i0 + 1;
    float x0 = x - i0;
    float x1 = x0 - 1.0f;

    float t0 = 1.0f - x0 * x0;
    t0 *= t0;
    n0 = t0 * t0 * grad(hash(i0), x0);

    float t1 = 1.0f - x1 * x1;
    t1 *= t1;
    n1 = t1 * t1 * grad(hash(i1), x1);
    return 0.395f * (n0 + n1);
}
float noise(float x, float y) {
    float n0, n1, n2;
    const float F2 = 0.366025403f;
    const float G2 = 0.211324865f;

    const float s = (x + y) * F2;
    const float xs = x + s, ys = y + s;
    const int i = fastfloor(xs), j = fastfloor(ys);

    const float t = float(i + j) * G2;
    const float X0 = i - t, Y0 = j - t;
    const float x0 = x - X0, y0 = y - Y0;

    int i1, j1;
    if (x0 > y0) {
        i1 = 1, j1 = 0;
    } else {
        i1 = 0, j1 = 1;
    }

    const float x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
    const float x2 = x0 - 1.0f + 2.0f * G2, y2 = y0 - 1.0f + 2.0f * G2;

    const int gi0 = hash(i + hash(j));
    const int gi1 = hash(i + i1 + hash(j + j1));
    const int gi2 = hash(i + 1 + hash(j + 1));

    float t0 = 0.5f - x0 * x0 - y0 * y0;
    if (t0 < 0.0f) {
        n0 = 0.0f;
    } else {
        t0 *= t0;
        n0 = t0 * t0 * grad(gi0, x0, y0);
    }

    float t1 = 0.5f - x1 * x1 - y1 * y1;
    if (t1 < 0.0f) {
        n1 = 0.0f;
    } else {
        t1 *= t1;
        n1 = t1 * t1 * grad(gi1, x1, y1);
    }

    float t2 = 0.5f - x2 * x2 - y2 * y2;
    if (t2 < 0.0f) {
        n2 = 0.0f;
    } else {
        t2 *= t2;
        n2 = t2 * t2 * grad(gi2, x2, y2);
    }

    return 45.23065f * (n0 + n1 + n2);
}
float noise(float x, float y, float z) {
    float n0, n1, n2, n3;

    const float F3 = 1.0f / 3.0f;
    const float G3 = 1.0f / 6.0f;

    float s = (x + y + z) * F3;
    int i = fastfloor(x + s), j = fastfloor(y + s), k = fastfloor(z + s);
    float t = (i + j + k) * G3;
    float X0 = i - t, Y0 = j - t, Z0 = k - t;
    float x0 = x - X0, y0 = y - Y0, z0 = z - Z0;

    int i1, j1, k1;
    int i2, j2, k2;
    if (x0 >= y0) {
        if (y0 >= z0) {
            i1 = 1, j1 = 0, k1 = 0;
            i2 = 1, j2 = 1, k2 = 0;
        } else if (x0 >= z0) {
            i1 = 1, j1 = 0, k1 = 0;
            i2 = 1, j2 = 0, k2 = 1;
        } else {
            i1 = 0, j1 = 0, k1 = 1;
            i2 = 1, j2 = 0, k2 = 1;
        }
    } else {
        if (y0 < z0) {
            i1 = 0, j1 = 0, k1 = 1;
            i2 = 0, j2 = 1, k2 = 1;
        } else if (x0 < z0) {
            i1 = 0, j1 = 1, k1 = 0;
            i2 = 0, j2 = 1, k2 = 1;
        } else {
            i1 = 0, j1 = 1, k1 = 0;
            i2 = 1, j2 = 1, k2 = 0;
        }
    }

    float x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
    float x2 = x0 - i2 + 2.0f * G3, y2 = y0 - j2 + 2.0f * G3, z2 = z0 - k2 + 2.0f * G3;
    float x3 = x0 - 1.0f + 3.0f * G3, y3 = y0 - 1.0f + 3.0f * G3, z3 = z0 - 1.0f + 3.0f * G3;

    int gi0 = hash(i + hash(j + hash(k)));
    int gi1 = hash(i + i1 + hash(j + j1 + hash(k + k1)));
    int gi2 = hash(i + i2 + hash(j + j2 + hash(k + k2)));
    int gi3 = hash(i + 1 + hash(j + 1 + hash(k + 1)));

    float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
    if (t0 < 0) {
        n0 = 0.0;
    } else {
        t0 *= t0;
        n0 = t0 * t0 * grad(gi0, x0, y0, z0);
    }
    float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
    if (t1 < 0) {
        n1 = 0.0;
    } else {
        t1 *= t1;
        n1 = t1 * t1 * grad(gi1, x1, y1, z1);
    }
    float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
    if (t2 < 0) {
        n2 = 0.0;
    } else {
        t2 *= t2;
        n2 = t2 * t2 * grad(gi2, x2, y2, z2);
    }
    float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
    if (t3 < 0) {
        n3 = 0.0;
    } else {
        t3 *= t3;
        n3 = t3 * t3 * grad(gi3, x3, y3, z3);
    }
    return 32.0f * (n0 + n1 + n2 + n3);
}

struct FractalNoiseConfig {
    float amplitude;
    float persistance;
    float scale;
    float lacunarity;
    uint octaves;
};

float fractal_noise(vec3 pos, FractalNoiseConfig config) {
    float value = 0.0f;
    for (int i = 0; i < config.octaves; ++i) {
        vec3 p = pos * config.scale;
        value += noise(p.x, p.y, p.z) * config.amplitude;
        config.amplitude *= config.persistance;
        config.scale *= config.lacunarity;
    }
    return value;
}

float terrain_noise(vec3 pos) {
    FractalNoiseConfig noise_conf = FractalNoiseConfig(
        /* .amplitude   = */ 0.1f,
        /* .persistance = */ 0.6f,
        /* .scale       = */ 0.005f,
        /* .lacunarity  = */ 2,
        /* .octaves     = */ 4);
    return fractal_noise(pos, noise_conf) * 3.0f - pos.y * 0.010f + 0.01f;
}

float biome_noise(vec3 pos) {
    FractalNoiseConfig noise_conf = FractalNoiseConfig(
        /* .amplitude   = */ 0.1f,
        /* .persistance = */ 0.4f,
        /* .scale       = */ 0.005f,
        /* .lacunarity  = */ 4,
        /* .octaves     = */ 4);
    return fractal_noise(pos + 1000, noise_conf) * 3.0f;
}

// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
uint rand_hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}
uint rand_hash(uvec2 v) { return rand_hash(v.x ^ rand_hash(v.y)); }
uint rand_hash(uvec3 v) { return rand_hash(v.x ^ rand_hash(v.y) ^ rand_hash(v.z)); }
uint rand_hash(uvec4 v) { return rand_hash(v.x ^ rand_hash(v.y) ^ rand_hash(v.z) ^ rand_hash(v.w)); }
float floatConstruct(uint m) {
    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitgmask
    const uint ieeeOne = 0x3F800000u;      // 1.0 in IEEE binary32
    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
    m |= ieeeOne;                          // Add fractional part to 1.0
    float f = uintBitsToFloat(m);          // Range [1:2]
    return f - 1.0;                        // Range [0:1]
}
// Pseudo-random value in half-open range [0:1].
float rand(float x) { return floatConstruct(rand_hash(floatBitsToUint(x))); }
float rand(vec2 v) { return floatConstruct(rand_hash(floatBitsToUint(v))); }
float rand(vec3 v) { return floatConstruct(rand_hash(floatBitsToUint(v))); }
float rand(vec4 v) { return floatConstruct(rand_hash(floatBitsToUint(v))); }

uint gen_block(in vec3 b_pos) {
    float b_val = biome_noise(b_pos);
    float val = terrain_noise(b_pos);
    float r = rand(b_pos);

    uint biome_id = Plains;
    if (b_val < -0.2)
        biome_id = Forest;
    else if (b_val > 0.12)
        biome_id = Desert; 
    if (b_pos.y > -4 + r * 3 && b_pos.y < 4 + r * 3 && val < 0.05 + r * 0.1 && val > -0.05 - r * 0.1)
        biome_id = Beach;

    biome_id = biome_id << 16;

    if (val > 0.0f) {
        return Stone | biome_id;
    } else {
        if (b_pos.y < 0) {
            return Water | biome_id;
        }
    }
    return Air | biome_id;
}

void main() {
    uvec3 global_i = gl_GlobalInvocationID.xyz;

    uvec3 chunk_i = global_i / CHUNK_SIZE.xyz;
    uvec3 block_i = global_i % CHUNK_SIZE.xyz;

    uint block_index = block_i.x + block_i.y * CHUNK_SIZE.x + block_i.z * CHUNK_SIZE.x * CHUNK_SIZE.y;
    uint chunk_index = chunk_i.x + chunk_i.y * CHUNK_MAX.x + chunk_i.z * CHUNK_MAX.x * CHUNK_MAX.y;
    vec3 block_pos = vec3(global_i) + p.pos * CHUNK_SIZE;

    chunks_0[chunk_index].blocks[block_index] = gen_block(block_pos);
}
