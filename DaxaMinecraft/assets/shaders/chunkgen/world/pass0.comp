#version 450
#extension GL_KHR_vulkan_glsl : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#include <chunkgen/common.glsl>
#include <chunkgen/world/noise.glsl>

const float water_level = 100;
const float lava_level = 458;

void biome_pass0(in out WorldgenState worldgen_state, in vec3 b_pos) {
    worldgen_state.biome_id = BiomeID_Plains;
    if (worldgen_state.b_noise < -0.07)
        worldgen_state.biome_id = BiomeID_Forest;
    else if (worldgen_state.b_noise > 0.22)
        worldgen_state.biome_id = BiomeID_Desert;
    if (b_pos.y - water_level > -4 + worldgen_state.r * 3 &&
        b_pos.y - water_level < 4 + worldgen_state.r * 3 &&
        worldgen_state.t_noise < 0.05 + worldgen_state.r * 0.1 &&
        worldgen_state.t_noise > -0.05 - worldgen_state.r * 0.1) {
        worldgen_state.biome_id = BiomeID_Beach;
    }
}

void block_pass0(in out WorldgenState worldgen_state, in vec3 b_pos) {
    worldgen_state.block_id = BlockID_Air;
    if (worldgen_state.t_noise > 0) {
        // if (b_pos.y > water_level + 80 + worldgen_state.t_noise * 20 + worldgen_state.r * 60) {
        //     worldgen_state.block_id = BlockID_CompressedStone;
        // } else {
        worldgen_state.block_id = BlockID_Stone;
        // }
        // if (worldgen_state.t_noise > 3) {
        //     worldgen_state.biome_id = BiomeID_Underworld;
        //     if (worldgen_state.u_noise < 0) {
        //         worldgen_state.block_id = BlockID_Air;
        //         if (b_pos.y > lava_level)
        //             worldgen_state.block_id = BlockID_Lava;
        //     }
        // } else if (worldgen_state.t_noise > 0.5) {
        //     worldgen_state.biome_id = BiomeID_Caves;
        //     if (worldgen_state.c_noise < 0)
        //         worldgen_state.block_id = BlockID_Air;
        // }
    } else if (b_pos.y > water_level) {
        worldgen_state.block_id = BlockID_Water;
    }
}

struct SurroundingInfo {
    uint above_ids[15];
    uint below_ids[15];
    uint depth_above;
    uint depth_below;
    bool above_water, under_water;
};

SurroundingInfo get_surrounding(in out WorldgenState worldgen_state, in vec3 b_pos) {
    SurroundingInfo result;

    for (int i = 0; i < 15; ++i) {
        WorldgenState temp;
        vec3 sample_pos;

        sample_pos = b_pos + vec3(0, i + 1, 0);
        temp = get_worldgen_state(sample_pos);
        block_pass0(temp, sample_pos);
        result.below_ids[i] = temp.block_id;

        sample_pos = b_pos + vec3(0, -i - 1, 0);
        temp = get_worldgen_state(sample_pos);
        block_pass0(temp, sample_pos);
        result.above_ids[i] = temp.block_id;
    }

    result.depth_above = 0;
    result.depth_below = 0;
    result.above_water = false;
    result.under_water = false;

    if (worldgen_state.block_id == BlockID_Air) {
        for (; result.depth_above < 15; ++result.depth_above) {
            if (result.above_ids[result.depth_above] == BlockID_Water)
                result.under_water = true;
            if (!is_transparent(result.above_ids[result.depth_above]))
                break;
        }
        for (; result.depth_below < 15; ++result.depth_below) {
            if (result.below_ids[result.depth_below] == BlockID_Water)
                result.above_water = true;
            if (!is_transparent(result.below_ids[result.depth_below]))
                break;
        }
    } else {
        for (; result.depth_above < 15; ++result.depth_above) {
            if (result.above_ids[result.depth_above] == BlockID_Water)
                result.under_water = true;
            if (is_transparent(result.above_ids[result.depth_above]))
                break;
        }
        for (; result.depth_below < 15; ++result.depth_below) {
            if (result.below_ids[result.depth_below] == BlockID_Water)
                result.above_water = true;
            if (is_transparent(result.below_ids[result.depth_below]))
                break;
        }
    }

    return result;
}

void block_pass1(in out WorldgenState worldgen_state, in vec3 b_pos, in SurroundingInfo surroundings) {
    if (!is_transparent(worldgen_state.block_id)) {
        switch (worldgen_state.biome_id) {
        case BiomeID_Beach:
            worldgen_state.block_id = BlockID_Sand;
            break;
        case BiomeID_Caves:
            break;
        case BiomeID_Underworld:
            if (surroundings.depth_above < worldgen_state.r * 4) {
                if (b_pos.y > lava_level - 2 + worldgen_state.r * 4)
                    worldgen_state.block_id = BlockID_MoltenRock;
                else
                    worldgen_state.block_id = BlockID_Bedrock;
            } else if (surroundings.depth_below < worldgen_state.r * 4) {
                worldgen_state.block_id = BlockID_Bedrock;
            }
            break;
        case BiomeID_Plains:
        case BiomeID_Forest:
            if (!surroundings.under_water) {
                if (surroundings.depth_above == 0) {
                    worldgen_state.block_id = BlockID_Grass;
                } else if (surroundings.depth_below < worldgen_state.r * 2) {
                    worldgen_state.block_id = BlockID_Cobblestone;
                } else if (surroundings.depth_above < 4 + worldgen_state.r * 6) {
                    worldgen_state.block_id = BlockID_Dirt;
                } else if (surroundings.depth_above < 15) {
                    if (worldgen_state.r < 0.1)
                        worldgen_state.block_id = BlockID_Dirt;
                    else if (worldgen_state.r < 0.2)
                        worldgen_state.block_id = BlockID_Gravel;
                }
            }
            break;
        case BiomeID_Desert:
            if (surroundings.depth_above < 2 + worldgen_state.r * 2) {
                worldgen_state.block_id = BlockID_Sand;
            } else if (surroundings.depth_above < 4 + worldgen_state.r * 6) {
                worldgen_state.block_id = BlockID_Sandstone;
            } else if (surroundings.depth_above < 15) {
                if (worldgen_state.r < 0.1)
                    worldgen_state.block_id = BlockID_Sand;
                else if (worldgen_state.r < 0.2)
                    worldgen_state.block_id = BlockID_Gravel;
            }
            break;
        }
    } else if (worldgen_state.block_id == BlockID_Air && !surroundings.above_water) {
        switch (worldgen_state.biome_id) {
        case BiomeID_Plains:
            if (surroundings.depth_below == 0) {
                if (worldgen_state.r < 0.10) {
                    worldgen_state.block_id = BlockID_TallGrass;
                } else if (worldgen_state.r < 0.11) {
                    worldgen_state.block_id = BlockID_Leaves;
                }
            }
            break;
        case BiomeID_Forest:
            if (worldgen_state.r_xz < 0.01) {
                int trunk_height = int(5 + worldgen_state.r_xz * 400);
                if (surroundings.depth_below < trunk_height) {
                    worldgen_state.block_id = BlockID_Log;
                }
            } else if (worldgen_state.r < 0.6 && surroundings.depth_below == 0) {
                worldgen_state.block_id = BlockID_Leaves;
            }
            break;
        case BiomeID_Desert:
            if (worldgen_state.r_xz < 0.001) {
                int trunk_height = int(5 + worldgen_state.r_xz * 400);
                if (surroundings.depth_below < trunk_height) {
                    worldgen_state.block_id = BlockID_Cactus;
                }
            } else if (worldgen_state.r < 0.02 && surroundings.depth_below == 0) {
                worldgen_state.block_id = BlockID_DriedShrub;
            }
            break;
        }
    }
}

uint gen_block(in vec3 b_pos) {
    WorldgenState worldgen_state = get_worldgen_state(b_pos);

    biome_pass0(worldgen_state, b_pos);
    block_pass0(worldgen_state, b_pos);
    SurroundingInfo surroundings = get_surrounding(worldgen_state, b_pos);
    block_pass1(worldgen_state, b_pos, surroundings);

    return worldgen_state.block_id;
}

void main() {
    uvec3 global_i = gl_GlobalInvocationID.xyz;
    vec3 block_pos = vec3(global_i) + p.pos.xyz - BLOCK_N / 2;
    imageStore(output_image, ivec3(global_i), uvec4(gen_block(block_pos)));
}
