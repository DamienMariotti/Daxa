#version 450
#extension GL_KHR_vulkan_glsl : enable

layout(local_size_x = 8, local_size_y = 8) in;

#include "drawing/common.glsl"

uvec4 get_tile(vec3 pos) {
    ivec3 chunk_i = ivec3(pos / 64);
    return imageLoad(chunk_images(chunk_i), ivec3(pos.x, pos.y, pos.z) - chunk_i * 64);
}

uint get_block_id(vec3 p) {
    return uint(get_tile(p).r);
}

bool is_voxel_occluding(vec3 p) {
    return (get_block_id(p) & 0xffff) != 0;
}

#include <utils/ray.glsl>

Ray sun_ray;
const vec3 sun_col = vec3(2, 1.8, 1);

vec3 sample_sky(vec3 nrm) {
    float sun_val = clamp((dot(nrm, sun_ray.nrm) - 0.9995) * 5000, 0, 1);
    float sky_val = (dot(nrm, vec3(0, 1, 0))) / 2 + clamp((dot(nrm, sun_ray.nrm) + 1) * 0.1, 0, 1);
    return sun_col * sun_val + mix(vec3(0.5, 0.6, 2), vec3(0.1, 0.2, 0.5), sky_val);
}

RayIntersection trace_chunks(in Ray ray) {
    RayIntersection result;
    result.hit = false;

    for (uint zi = 0; zi < CHUNK_N.z; ++zi) {
        for (uint yi = 0; yi < CHUNK_N.y; ++yi) {
            for (uint xi = 0; xi < CHUNK_N.x; ++xi) {
                RayIntersection ri = ray_step_voxels(ray, vec3(64) * vec3(xi, yi, zi));
                if (ri.hit && (ri.dist < result.dist || !result.hit))
                    result = ri;
            }
        }
    }

    return result;
}

void main() {
    if (gl_GlobalInvocationID.x >= globals.frame_dim.x ||
        gl_GlobalInvocationID.y >= globals.frame_dim.y)
        return;

    vec2 inv_frame_dim = 1 / vec2(globals.frame_dim);
    float aspect = float(globals.frame_dim.x) * inv_frame_dim.y;
    ivec2 i_uv = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(i_uv) * inv_frame_dim * 2 - 1;
    vec3 color = vec3(0);
    const vec2 subsamples = vec2(2);
    const vec2 inv_subsamples = 1 / subsamples;

    vec3 front = (globals.viewproj_mat * vec4(0, 0, 1, 0)).xyz;
    vec3 right = (globals.viewproj_mat * vec4(1, 0, 0, 0)).xyz;
    vec3 up = (globals.viewproj_mat * vec4(0, 1, 0, 0)).xyz;

    float sun_angle = 0.5;
    sun_ray.nrm = normalize(vec3(sin(sun_angle) * 3, -cos(sun_angle) * 3, 1));
    sun_ray.inv_nrm = 1 / sun_ray.nrm;

    for (uint yi = 0; yi < subsamples.y; ++yi) {
        for (uint xi = 0; xi < subsamples.x; ++xi) {
            vec2 view_uv = uv * 1 * vec2(aspect, 1) + inv_frame_dim * vec2(xi, yi) * inv_subsamples;

            Ray cam_ray;
            cam_ray.o = globals.pos.xyz;
            cam_ray.nrm = normalize(front + view_uv.x * right + view_uv.y * up);
            cam_ray.inv_nrm = 1 / cam_ray.nrm;

            RayIntersection ray_chunk_intersection = trace_chunks(cam_ray);

            if (ray_chunk_intersection.hit) {
                vec3 intersection_pos = get_intersection_pos(cam_ray, ray_chunk_intersection);
                sun_ray.o = intersection_pos + ray_chunk_intersection.nrm * 0.01;
                RayIntersection sun_ray_chunk_intersection = trace_chunks(sun_ray);
                float val = float(!sun_ray_chunk_intersection.hit);
                val = max(val * dot(ray_chunk_intersection.nrm, sun_ray.nrm), 0.01);
                vec3 light = val * sun_col + sample_sky(ray_chunk_intersection.nrm) * 0.2;
                // vec3 light = sun_col + sample_sky(ray_chunk_intersection.nrm) * 0.2;
                vec3 b_uv = vec3(ivec3(intersection_pos) % 16) / 16;
                vec3 albedo = texture(get_texture[globals.texture_index], vec3(b_uv.xz, 10)).rgb;
                color += albedo * light;
            } else {
                color += sample_sky(cam_ray.nrm);
            }
        }
    }

    color *= inv_subsamples.x * inv_subsamples.y;

    imageStore(output_image, i_uv, vec4(color, 1));
}
